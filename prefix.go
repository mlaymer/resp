package resp

// Prefix используется для определения типа данных в ответе
// Redis в зависимости от реализации команды.
// Поддерживаемые типы данных:
//	Простые строки, "+"
//	Ошибки, "-"
//	Числа, ":"
//	Объёмные строки, "$"
//	Массивы, "*"
// Стоит обратить внимание, что Redis также поддерживает значения Null,
// используя специальный синтаксис в объёмных строках и массивах.
//	Смотри:
//	https://redis.io/topics/protocol#resp-protocol-description
type Prefix byte

const (
	// PrefixSimpleStrings используется для обозначения
	// типа данных "простая строка".
	// Простая строка кодируется следующим образом:
	// символ "+", за ней следует строка, которая не содержит CLRF
	// (в простых строках не поддерживаются переносы строк) и CLRF,
	// завершающая строку.
	// Простые строки используются для передачи небинарных безопасных
	// строк с минимальными накладными расходами.
	//	Пример:
	//	"+OK\r\n"
	//
	//	Смотри:
	//	https://redis.io/topics/protocol#resp-simple-strings
	PrefixSimpleStrings Prefix = '+'

	// PrefixErrors используется для обозначения типа
	// данных "ошибка".
	// Ошибки кодируются так же как и простые строки с той лишь разницей,
	// что в ошибках вместо символа "+" используется "-".
	// Реальное отличие ошибок и простых строк в том, что ошибки клиент
	// должен интерпретировать как исключения, а строка с ошибкой содержит
	// текст сообщения об ошибке. Ответы с ошибками отправляются только тогда,
	// когда что-то происходит не так, например, работа с некорректным типом
	// данных или если команда не существует.
	//	Пример:
	//	"-Error message\r\n"
	// Стоит также обратить внимание, что в RESP используется соглашение о
	// типах ошибок. Тип ошибки начинается сразу после символа "-" и
	// завершается либо пробелом, либо CLRF. Тип ошибки называется
	// "префиксом ошибки". Тип ошибок не следует считать жизненно важным,
	// т.к. он может не указываться вовсе.
	//	Примеры ошибок с префиксом:
	//	-ERR unknown command 'foobar'
	//	-WRONGTYPE Operation against a key holding the wrong kind of value
	//
	//	Смотри:
	//	https://redis.io/topics/protocol#resp-errors
	PrefixErrors Prefix = '-'

	// PrefixIntegers используется для обозначения типа
	// данных "числа".
	// Числа в RESP представляют из себя символ ":" в начале,
	// строковое представление числа и CLRF в конце.
	// Числа в Redis гарантированно располагаются в диапазоне
	// 64-битного целого числа со знаком.
	//	Примеры:
	//	":0\r\n"
	//	":1000\r\n"
	//
	//	Смотри:
	//	https://redis.io/topics/protocol#resp-integers
	PrefixIntegers Prefix = ':'

	// PrefixBulkStrings используется для обозначения
	// типа данных "объёмная строка".
	// Объёмные строки кодируются следующим образом:
	//	1). Начало с символа "$", за ним длина строки и CLRF
	//	2). Полезная нагрузка строки
	//	3). Завершающий CLRF
	//
	//	Примеры:
	//	"$6\r\nfoobar\r\n"
	//	"$0\r\n\r\n" (пустая строка)
	// Объёмные строки поддерживают синтаксис для определения
	// значения Null:
	//	"$-1\r\n"
	// Следует обратить внимание, что клиентские реализации
	// при получении Null-строки не должны возвращать пустую
	// строку, а объект nil.
	//
	//	Смотри:
	//	https://redis.io/topics/protocol#resp-bulk-strings
	PrefixBulkStrings Prefix = '$'

	// PrefixArrays используется для обозначения
	// типа данных "массив".
	// Массивы в RESP кодируются следующим образом:
	//	1). Символ "*" в начале, число элементов массива в виде десятичного числа и CLRF.
	//	2). Дополнительный тип RESP для каждого элемента массива.
	//
	//	Примеры:
	//	"*-1\r\n" (Null-массив)
	//	"*0\r\n" (пустой массив)
	//	"*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n" (массив из двух строк "foo" и "bar")
	// Массивы также поддерживают Null-элементы ("$-1\r\n").
	//
	//	Смотри:
	//	https://redis.io/topics/protocol#resp-arrays
	PrefixArrays Prefix = '*'
)

func (p Prefix) Validate() error {
	switch p {
	case PrefixSimpleStrings, PrefixErrors, PrefixIntegers, PrefixBulkStrings, PrefixArrays:
		return nil
	}

	return ErrConstraintsViolated
}
